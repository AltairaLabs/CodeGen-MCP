package coordinator

import (
	"context"
	"encoding/json"
	"errors"
	"sync"
	"testing"
	"time"

	"github.com/AltairaLabs/codegen-mcp/internal/coordinator/cache"
	"github.com/AltairaLabs/codegen-mcp/internal/coordinator/storage"
	"github.com/mark3labs/mcp-go/mcp"
)

const (
	taskGetResult       = "task.get_result"
	taskGetStatus       = "task.get_status"
	errUnexpected       = "unexpected error: %v"
	errFailedUnmarshal  = "failed to unmarshal status: %v"
	errUnexpectedStatus = "unexpected status: %+v"
	errNotFound         = "not found"
	errExpectedResult   = "expected result, got nil"
	errExpectedText     = "expected TextContent, got %T"
)

// mockTaskQueueWithStorage wraps the existing MockTaskQueue to allow custom GetTask behavior
type mockTaskQueueWithStorage struct {
	*MockTaskQueue
	task *storage.QueuedTask
	err  error
}

func (m *mockTaskQueueWithStorage) GetTask(ctx context.Context, taskID string) (*storage.QueuedTask, error) {
	return m.task, m.err
}

func TestHandleGetTaskResultResultReady(t *testing.T) {
	cache := cache.NewResultCache(5 * time.Minute)

	// Pre-populate cache with result
	taskID := "id1"
	result := &TaskResult{Output: "hello world"}
	adapter := NewTaskResultAdapter(result)
	_ = cache.Store(context.Background(), taskID, adapter)

	ms := &MCPServer{
		resultCache: cache,
		taskQueue:   &MockTaskQueue{},
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetResult,
			Arguments: map[string]interface{}{"task_id": taskID},
		},
	}
	result, err := ms.handleGetTaskResult(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	// Check that result contains the output text
	if len(result.Content) == 0 {
		t.Fatal("expected content in result")
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	if text.Text != "hello world" {
		t.Errorf("expected 'hello world', got %s", text.Text)
	}
}

func TestHandleGetTaskResultNotReadyReturnsStatus(t *testing.T) {
	now := time.Now()
	cache := NewResultCache(5 * time.Minute)

	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task: &storage.QueuedTask{
			ID:        "id2",
			State:     storage.TaskStateQueued,
			SessionID: "sess1",
			Sequence:  42,
			CreatedAt: now,
		},
		err: nil,
	}
	ms := &MCPServer{
		resultCache: cache,
		taskQueue:   queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetResult,
			Arguments: map[string]interface{}{"task_id": "id2"},
		},
	}
	result, err := ms.handleGetTaskResult(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	// Extract text content
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	var status TaskResponse
	if err := json.Unmarshal([]byte(text.Text), &status); err != nil {
		t.Fatalf(errFailedUnmarshal, err)
	}
	if status.TaskID != "id2" || status.Status != string(storage.TaskStateQueued) {
		t.Errorf(errUnexpectedStatus, status)
	}
}

func TestHandleGetTaskResultTaskNotFound(t *testing.T) {
	cache := NewResultCache(5 * time.Minute)

	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task:          nil,
		err:           errors.New(errNotFound),
	}
	ms := &MCPServer{
		resultCache: cache,
		taskQueue:   queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetResult,
			Arguments: map[string]interface{}{"task_id": "id3"},
		},
	}
	result, err := ms.handleGetTaskResult(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	// Check for error content
	if len(result.Content) == 0 {
		t.Fatal("expected content in result")
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	if text.Text == "" {
		t.Error("expected error message, got empty text")
	}
	if !result.IsError {
		t.Error("expected IsError to be true")
	}
}

func TestTaskQueueGetTaskResultSuccess(t *testing.T) {
	// Test GetTaskResult success path with channel cleanup
	tq := &TaskQueue{
		storage:        nil, // Not needed for this test
		resultChannels: make(map[string]chan *TaskResult),
		resultMu:       sync.RWMutex{},
	}

	taskID := "success-task"
	resultChan := make(chan *TaskResult, 1)
	tq.resultChannels[taskID] = resultChan

	// Send a result
	expectedResult := &TaskResult{
		Success:  true,
		Output:   "test output",
		ExitCode: 0,
	}
	resultChan <- expectedResult

	// Call GetTaskResult - should receive result and cleanup channel
	result, err := tq.GetTaskResult(context.Background(), taskID)
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}
	if result == nil {
		t.Fatal("expected result, got nil")
	}
	if result.Output != "test output" {
		t.Errorf("expected output 'test output', got %s", result.Output)
	}

	// Verify channel was cleaned up
	tq.resultMu.RLock()
	_, exists := tq.resultChannels[taskID]
	tq.resultMu.RUnlock()
	if exists {
		t.Error("expected result channel to be cleaned up after receiving result")
	}
}

func TestTaskQueueGetTaskResultTimeout(t *testing.T) {
	// Test GetTaskResult ctx.Done() path
	tq := &TaskQueue{
		storage:        nil, // Not needed for this test
		resultChannels: make(map[string]chan *TaskResult),
		resultMu:       sync.RWMutex{},
	}

	// Create a task with result channel that never sends
	taskID := "timeout-task"
	resultChan := make(chan *TaskResult)
	tq.resultChannels[taskID] = resultChan

	// Create context with immediate timeout
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)
	defer cancel()

	// Wait for context to expire
	time.Sleep(5 * time.Millisecond)

	// Call GetTaskResult - should return ctx error
	result, err := tq.GetTaskResult(ctx, taskID)
	if err == nil {
		t.Error("expected timeout error")
	}
	if result != nil {
		t.Errorf("expected nil result on timeout, got %v", result)
	}
	if !errors.Is(err, context.DeadlineExceeded) {
		t.Errorf("expected DeadlineExceeded error, got %v", err)
	}
}

func TestHandleGetTaskStatusCompleted(t *testing.T) {
	completed := time.Now()
	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task: &storage.QueuedTask{
			ID:          "id4",
			State:       storage.TaskStateCompleted,
			SessionID:   "sess2",
			Sequence:    99,
			CreatedAt:   time.Now().Add(-1 * time.Hour),
			CompletedAt: &completed,
		},
		err: nil,
	}
	ms := &MCPServer{
		taskQueue: queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetStatus,
			Arguments: map[string]interface{}{"task_id": "id4"},
		},
	}
	result, err := ms.handleGetTaskStatus(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	var status TaskResponse
	if err := json.Unmarshal([]byte(text.Text), &status); err != nil {
		t.Fatalf(errFailedUnmarshal, err)
	}
	if status.TaskID != "id4" || status.Status != string(storage.TaskStateCompleted) {
		t.Errorf(errUnexpectedStatus, status)
	}
	if status.Message == "" {
		t.Error("expected completion message, got empty")
	}
}

func TestHandleGetTaskStatusDispatched(t *testing.T) {
	dispatched := time.Now()
	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task: &storage.QueuedTask{
			ID:           "id5",
			State:        storage.TaskStateDispatched,
			SessionID:    "sess3",
			Sequence:     7,
			CreatedAt:    time.Now().Add(-2 * time.Hour),
			DispatchedAt: &dispatched,
		},
		err: nil,
	}
	ms := &MCPServer{
		taskQueue: queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetStatus,
			Arguments: map[string]interface{}{"task_id": "id5"},
		},
	}
	result, err := ms.handleGetTaskStatus(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	var status TaskResponse
	if err := json.Unmarshal([]byte(text.Text), &status); err != nil {
		t.Fatalf(errFailedUnmarshal, err)
	}
	if status.TaskID != "id5" || status.Status != string(storage.TaskStateDispatched) {
		t.Errorf(errUnexpectedStatus, status)
	}
	if status.Message == "" {
		t.Error("expected dispatched message, got empty")
	}
}

func TestHandleGetTaskStatusQueued(t *testing.T) {
	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task: &storage.QueuedTask{
			ID:        "id6",
			State:     storage.TaskStateQueued,
			SessionID: "sess4",
			Sequence:  123,
			CreatedAt: time.Now().Add(-3 * time.Hour),
		},
		err: nil,
	}
	ms := &MCPServer{
		taskQueue: queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetStatus,
			Arguments: map[string]interface{}{"task_id": "id6"},
		},
	}
	result, err := ms.handleGetTaskStatus(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	var status TaskResponse
	if err := json.Unmarshal([]byte(text.Text), &status); err != nil {
		t.Fatalf(errFailedUnmarshal, err)
	}
	if status.TaskID != "id6" || status.Status != string(storage.TaskStateQueued) {
		t.Errorf(errUnexpectedStatus, status)
	}
	if status.Message == "" {
		t.Error("expected queued message, got empty")
	}
}

func TestHandleGetTaskStatusTaskNotFound(t *testing.T) {
	queue := &mockTaskQueueWithStorage{
		MockTaskQueue: &MockTaskQueue{},
		task:          nil,
		err:           errors.New(errNotFound),
	}
	ms := &MCPServer{
		taskQueue: queue,
	}
	req := mcp.CallToolRequest{
		Params: mcp.CallToolParams{
			Name:      taskGetStatus,
			Arguments: map[string]interface{}{"task_id": "id7"},
		},
	}
	result, err := ms.handleGetTaskStatus(context.Background(), req)
	if err != nil {
		t.Fatalf(errUnexpected, err)
	}
	if result == nil {
		t.Fatal(errExpectedResult)
	}
	text, ok := result.Content[0].(mcp.TextContent)
	if !ok {
		t.Fatalf(errExpectedText, result.Content[0])
	}
	if text.Text == "" {
		t.Error("expected error message, got empty text")
	}
	if !result.IsError {
		t.Error("expected IsError to be true")
	}
}
