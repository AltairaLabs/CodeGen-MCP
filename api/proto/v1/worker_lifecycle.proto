syntax = "proto3";

package codegen.v1;

import "api/proto/v1/common.proto";
import "api/proto/v1/task_execution.proto";

option go_package = "github.com/altairalabs/codegen-mcp/api/proto/v1;protov1";

// WorkerLifecycle manages worker registration and health
service WorkerLifecycle {
  // Worker registers with coordinator on startup
  rpc RegisterWorker(RegisterRequest) returns (RegisterResponse);
  
  // Worker sends periodic heartbeat with health status and session capacity
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  
  // Worker gracefully deregisters before shutdown
  rpc DeregisterWorker(DeregisterRequest) returns (DeregisterResponse);
  
  // Worker opens a bidirectional stream for receiving task assignments from coordinator
  // Coordinator sends TaskAssignment messages, worker sends TaskResponse messages back
  rpc TaskStream(stream TaskStreamMessage) returns (stream TaskStreamMessage);
}

message RegisterRequest {
  string worker_id = 1;           // Unique worker identifier (from env)
  string auth_token = 2;          // Bearer token for authentication
  WorkerCapabilities capabilities = 3;
  ResourceLimits limits = 4;
  string version = 5;             // Worker binary version
  string grpc_address = 6;        // Worker's gRPC server address (e.g., "localhost:50051")
}

message WorkerCapabilities {
  repeated string supported_tools = 1;  // e.g., ["fs.write", "run.python"]
  repeated string languages = 2;        // e.g., ["python"]
  int32 max_sessions = 3;               // Max concurrent sessions this worker supports
  map<string, string> metadata = 4;     // Extensible metadata
}

message RegisterResponse {
  string session_id = 1;          // Worker's registration session ID
  string task_endpoint = 2;       // gRPC endpoint for task assignment
  int32 heartbeat_interval_sec = 3;
  bool accepted = 4;
  string reason = 5;              // If not accepted, why?
}

message HeartbeatRequest {
  string worker_id = 1;
  string session_id = 2;            // Worker's registration session ID
  WorkerStatus status = 3;
  SessionCapacity capacity = 4;     // Current session availability
}

message SessionCapacity {
  int32 total_sessions = 1;         // Max sessions worker can handle
  int32 active_sessions = 2;        // Currently running sessions
  int32 available_sessions = 3;     // Free session slots
  repeated SessionInfo sessions = 4;  // Details of active sessions
}

message WorkerStatus {
  enum State {
    STATE_UNSPECIFIED = 0;
    STATE_IDLE = 1;
    STATE_BUSY = 2;
    STATE_DRAINING = 3;
    STATE_UNHEALTHY = 4;
  }
  State state = 1;
  int32 active_tasks = 2;           // Total tasks across all sessions
  ResourceUsage current_usage = 3;  // Total resource usage
  repeated string errors = 4;       // Recent errors
}

message HeartbeatResponse {
  bool continue_serving = 1;
  repeated string commands = 2;    // e.g., ["drain", "reload_config"]
}

message DeregisterRequest {
  string worker_id = 1;
  string session_id = 2;            // Worker's registration session ID
  string reason = 3;                // Shutdown reason
}

message DeregisterResponse {
  bool acknowledged = 1;
}

// TaskStreamMessage is used for bidirectional task streaming
// Coordinator sends task assignments, worker sends responses
message TaskStreamMessage {
  oneof message {
    TaskAssignment assignment = 1;   // Coordinator -> Worker: execute this task
    TaskStreamResponse response = 2;  // Worker -> Coordinator: task update/result
    StreamKeepAlive keepalive = 3;    // Either direction: keep connection alive
    SessionCreateRequest session_create = 4;  // Coordinator -> Worker: create session
    SessionCreateResponse session_created = 5; // Worker -> Coordinator: session created
  }
}

// TaskAssignment is sent by coordinator to worker
// Reuses TaskContext and ExecutionConstraints from task_execution.proto
message TaskAssignment {
  string task_id = 1;
  string session_id = 2;
  string tool_name = 3;
  map<string, string> arguments = 4;
  TaskContext context = 5;
  ExecutionConstraints constraints = 6;
  uint64 sequence = 7;             // Monotonic sequence number for deduplication (0 = no tracking)
}

// TaskStreamResponse is sent by worker to coordinator
message TaskStreamResponse {
  string task_id = 1;
  oneof payload {
    TaskProgressUpdate progress = 2;
    TaskLogEntry log = 3;
    TaskStreamResult result = 4;
    TaskStreamError error = 5;
  }
}

message TaskProgressUpdate {
  int32 percent_complete = 1;
  string stage = 2;
  string message = 3;
}

message TaskLogEntry {
  enum Level {
    LEVEL_UNSPECIFIED = 0;
    LEVEL_DEBUG = 1;
    LEVEL_INFO = 2;
    LEVEL_WARN = 3;
    LEVEL_ERROR = 4;
  }
  Level level = 1;
  string message = 2;
  int64 timestamp_ms = 3;
  string source = 4;
}

message TaskStreamResult {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_SUCCESS = 1;
    STATUS_FAILURE = 2;
    STATUS_TIMEOUT = 3;
    STATUS_CANCELLED = 4;
  }
  Status status = 1;
  map<string, string> outputs = 2;
  repeated string artifacts = 3;
  TaskExecutionMetadata metadata = 4;
  uint64 sequence = 5;                        // Sequence number of completed task (for deduplication tracking)
  map<string, string> session_metadata = 6;   // Updated session metadata after task execution (worker is master)
}

message TaskExecutionMetadata {
  int64 start_time_ms = 1;
  int64 end_time_ms = 2;
  int64 duration_ms = 3;
  ResourceUsage peak_usage = 4;
  int32 exit_code = 5;
}

message TaskStreamError {
  string code = 1;
  string message = 2;
  string details = 3;
  bool retriable = 4;
}

message StreamKeepAlive {
  int64 timestamp_ms = 1;
}

// SessionCreateRequest is sent by coordinator to worker to create a new session
message SessionCreateRequest {
  string session_id = 1;        // Session ID to create
  string workspace_id = 2;      // Workspace identifier
  string user_id = 3;           // User/tenant identifier
  map<string, string> env_vars = 4;         // Environment variables for session
  map<string, string> metadata = 5;         // Initial session metadata
}

// SessionCreateResponse is sent by worker to coordinator after session creation
message SessionCreateResponse {
  string session_id = 1;        // Session ID that was created
  bool success = 2;             // Whether creation succeeded
  string error = 3;             // Error message if failed
  map<string, string> metadata = 4;  // Initial session metadata from worker
}
